on:
  push:
    branches:
      - own-api  
jobs:
  build-api:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v1

    - name: Log in to dockerhub
      uses: docker/login-action@v1
      with:
        username: ${{ secrets.DOCKER_USERNAME }}
        password: ${{ secrets.DOCKER_PASSWORD }}

    - name: Build and push QFT Api to docker
      uses: docker/build-push-action@v2
      with:
        push: true
        tags: ${{ secrets.DOCKER_USERNAME }}/qft:${{ github.sha }}
        file: ./server/Dockerfile
        context: ./server

  build-client:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v1

    - name: Log in to dockerhub
      uses: docker/login-action@v1
      with:
        username: ${{ secrets.DOCKER_USERNAME }}
        password: ${{ secrets.DOCKER_PASSWORD }}

    - name: Create env file
      run: |
        touch .env
        echo NEXT_PUBLIC_SUPABASE_URL=${{ secrets.SUPABASE_URL }} >> .env
        echo NEXT_PUBLIC_SUPABASE_ANON_KEY=${{ secrets.SUPABASE_ANON_KEY }} >> .env
        echo NEXT_PUBLIC_SERVER_URL=${{ secrets.SERVER_URL }} >> .env
        echo NEXT_PUBLIC_STORAGE_URL=${{ secrets.STORAGE_URL }} >> .env
        echo NEXT_PUBLIC_STRIPE_PUBLIC_KEY=${{ secrets.STRIPE_PUBLIC_KEY }} >> .env
        echo NEXT_PUBLIC_GO_AUTH_SERVER_URL=${{ secrets.GO_AUTH_SERVER_URL }} >> .env
    
    - name: Build and push QFT Client to docker
      uses: docker/build-push-action@v2
      with:
        push: true
        tags: ${{ secrets.DOCKER_USERNAME }}/qft-client
        file: ./client/Dockerfile
        context: ./client
    
    # # Set the target Azure Kubernetes Service (AKS) cluster. 
    # - uses: azure/aks-set-context@v1
    #   with:
    #     creds: '${{ secrets.AZURE_CREDENTIALS }}'
    #     cluster-name: ${{ env.CLUSTER_NAME }}
    #     resource-group: ${{ env.CLUSTER_RESOURCE_GROUP }}
    
    # # Create namespace if doesn't exist
    # - run: |
    #     kubectl create namespace ${{ env.NAMESPACE }} --dry-run=client -o json | kubectl apply -f -
    
    # # Create image pull secret for ACR
    # - uses: azure/k8s-create-secret@v1
    #   with:
    #     container-registry-url: ${{ env.REGISTRY_NAME }}.azurecr.io
    #     container-registry-username: ${{ secrets.REGISTRY_USERNAME }}
    #     container-registry-password: ${{ secrets.REGISTRY_PASSWORD }}
    #     secret-name: ${{ env.SECRET }}
    #     namespace: ${{ env.NAMESPACE }}
    #     arguments: --force true
    
    # # Deploy app to AKS
    # - uses: azure/k8s-deploy@v1
    #   with:
    #     manifests: |
    #       ${{ github.workspace }}/manifests/deployment.yaml
    #       ${{ github.workspace }}/manifests/service.yaml
    #     images: |
    #       ${{ env.REGISTRY_NAME }}.azurecr.io/${{ env.APP_NAME }}:${{ github.sha }}
    #     imagepullsecrets: |
    #       ${{ env.SECRET }}
    #     namespace: ${{ env.NAMESPACE }}